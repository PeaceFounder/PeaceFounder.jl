var documenterSearchIndex = {"docs":
[{"location":"schema/#REST-API","page":"REST","title":"REST API","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"This is an approximate rest API for the PeaceFounder. In future, this will be properly generated and documented from the code. ","category":"page"},{"location":"schema/","page":"REST","title":"REST","text":"GET /deme # returns a current manifest file\nGET /deme/{hash}\n\nPOST /tickets : Tuple{TicketID, DateTime, auth_code::Digest} -> Tuple{salt::Vector{UInt8}, auth_code::Digest} # resets token when repeated\nDELETE /tickets/{TicketID}\nPUT /tickets/{TicketID} : Tuple{Pseudonym, auth_code::Digest} -> Admission\nGET /tickets/{TicketID} : TicketStatus\n\nPOST /braidchain/members : Member -> AckInclusion{ChainState}\nGET /braidchain/members : Vector{Tuple{Int, Member}}\nGET /braidchain/members?id={Pseudonym} : Tuple{Int, Member}\nGET /braidchain/members?pseudonym={Pseudonym} : Tuple{Int, Member}\n\nPOST /braidchain/proposals : Proposal -> AckInclusion\nGET /braidcahin/proposals/{UUID} : Tuple{Int, Proposal}\nGET /braidchain/proposals : Vector{Tuple{Int, Proposal}}\n\nGET /braidchain/{Int}/record : Transaction\nGET /braidchain/{Int}/leaf : AckInclusion{ChainState}\nGET /braidchain/{Int}/root : AckConsistency{ChainState}\nGET /braidchain/commit : Commit{ChainState}\nGET /braidchain/tar : BraidChainArchive\n\nPOST /pollingstation/{UUID}/votes : Vote -> CastAck\nGET /pollingstation/{UUID}/spine : Vector{Digest}\nGET /pollingstation/{UUID}/commit : Commit{BallotBoxState}\nGET /pollingstation/{UUID}/proposal : Tuple{Int, Proposal}\nGET /pollingstation/{UUID}/votes/{Int}/record : CastRecord\nGET /pollingstation/{UUID}/votes/{Int}/receipt : CastReceipt\nGET /pollingstation/{UUID}/votes/{Int}/leaf : AckInclusion{BallotBoxState}\nGET /pollingstation/{UUID}/votes/{Int}/root : AckConsistency{BallotBoxState}\nGET /pollingstation/{UUID}/tar : BallotBoxArchive\nGET /pollingstation/collectors # necessary to make a proposal","category":"page"},{"location":"schema/#Braider","page":"REST","title":"Braider","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"GET /braider : BraiderStatus\nGET /braider/jobs : Vector{JobID}\nGET /braider/jobs/{JobID} : JobStatus\nGET /braider/jobs/{JobID}/braid : Braid\nPOST /braider/jobs : BraidJobSpec -> JobID\nPUT /braider/jobs/{JobID} : Tuple{Vector{Pseudonym}, Generator} -> JobStatus","category":"page"},{"location":"schema/#Admin","page":"REST","title":"Admin","text":"","category":"section"},{"location":"schema/","page":"REST","title":"REST","text":"Note that at this level I also need to implement authetification. ","category":"page"},{"location":"schema/","page":"REST","title":"REST","text":"POST /admin/ticket : Tuple{Pseudonym, CryptoSpec, token::BigInt} # sets up the guardian\nGET /admin/ticket : Pseudonym\n\nGET /admin/braider : BraiderStatus\nPUT /admin/braider : BraiderCommand -> BraiderStatus\n# restarting process in case of errors\n# setting allowed cryptographic groups\n# making an allowlist or blocklist\n# setting braider key\n\nGET /admin/broker : BraidBrokerStatus\nPUT /admin/broker : BraidBrokerCommand -> BraidBraiderStatus\n# adding a braider location\n# starting brading manually\n# scheduling braiding\n# restarting process in case of errors\n\nGET /admin/dealer : DealerStatus # contains scheduled jobs\nPUT /admin/dealer : DealerCommand -> DealerStatus\n# adding beacon location\n# sending a pulse manually\n# passing lot without pulse\n\nGET /admin/recruiter : RecruiterStatus\nPUT /admin/recruiter : RecruiterCommand -> RecruiterStatus\n# setting a recruiter key\n# sets up a secret key a third party can use to push new forms and retrieve tokens\n\nGET /admin/pollingstation : PollingStationStatus # contains a list of collectors\nPUT /admin/pollingstation : PollingStaionCommand -> PollingStationStatus\n# generates a collector key\n# tally a given proposal manually\n# adding an allowlist for monitors (who gets to backup votes)\n# adding an allowlist for third party collectors who get to submit votes in case of DDOS attack","category":"page"},{"location":"audit/#Audit","page":"Audit","title":"Audit","text":"","category":"section"},{"location":"audittools/#PeaceFounder.AuditTools","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools","text":"","category":"section"},{"location":"audittools/","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools","text":"PeaceFounder.AuditTools","category":"page"},{"location":"audittools/","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools","text":"Modules = [PeaceFounder.AuditTools]\nOrder = [:module, :type, :function]","category":"page"},{"location":"audittools/#PeaceFounder.AuditTools","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools","text":"After ellections have ended the collector publishes a tally. To assert that votes have been  accuratelly counted and that only legitimate voters have participated an audit takes place.\n\nEvery voter after ellections receives a final tally together with a consistency proof  which proves that their vote is included in the ledger which have produced the tally.  From the voter client voter reads four important parameters for the ballotbox:\n\ndeme_uuid: an UUID of the deme where the proposal is registered;\nproposal_index: a index at which the proposal is recorded in the braidchain ledger;\nledger_length: a number of collected votes in the ledger;\nledger_root: a ballotbox ledger root checksum.\n\nThe auditor also knows a hasher deme uses to make checksums which is immutable at the moment deme is created.\n\nLet's consider abstract functions to retrieve ballotbox and braidchain ledger archives from the internet with get_ballotbox_archive and get_braidchain_archive then the auditing can be done with a following script:\n\nbraidchain_archive = get_ballotbox_archive(uuid)\nballotbox_archive = get_ballotbox_archive(uuid, proposal_index)[1:ledger_length]\n\n@test checksum(ballotbox_archive, hasher) == ledger_root\n@test isbinding(braidchain_archive, ballotbox_archive, hasher)\n\nspec = crypto(braidchain_archive)\n\n@test audit(ballotbox_archive, spec)\n@test audit(braidchain_archive)\n\n@show tally(ballotbox_archive)\n\nNote that spec is read from the DemeSpec record in the braidchain which can be trusted as  the tree braidchain ledger checksum is listed within a proposal's anchor. The proposal is  the first record in history tree for the ballotbox thus it is bound to ledger_root  checksum and so demespec record is also tied to ledger_root.\n\nFor convinience an audit method is provided which audits both archives at the same time:\n\nbraidchain_archive = get_ballotbox_archive(uuid)\nballotbox_archive = get_ballotbox_archive(uuid, proposal_index)[1:ledger_length]\n\n@test checksum(ballotbox_archive, hasher) == ledger_root\n@test audit(braidchain_archive, ballotbox_archive, hasher)\n\n@show tally(ballotbox_archive)\n\nNote that this audit does not check honesty of the registrar that it have not admitted fake users to gain more influence in the ellection result. Properties being verified by the audit:\n\nLegitimacy: only and all eligiable voters cast their votes;\nFairness: every eligiable voter can vote at most once;\nImmutability: no vote can be deleted or modified when recorded in the ledger; \nTallied as Cast: all cast votes are counted honestly to predetermined procedure; \nSoftware independence: the previously audited properties for the evidence does not \n\ndepend on a trust in honest execution of peacefounder service nor honesty of the braiders who provides new pseudonyms for the deme members. In other words the previously listed  properties would not be altered if adversary would have a full control over the peacefounder  service and the braiders. \n\nThe immutability is ensured from voter's clients updating their consistency proof chain which includes their vote. If the vote gets removed from a chain every single voter who had cast their vote would get a proof for inconsistent ledger state called blame. The blame can be made public by the voter without revealing it's vote and thus ensures immutability and also persitance after votes are published. The auditable part here are the votes themselves signed with pseudonym which contract voter's clients to follow up at latter periods with consistency proofs. On top of that, other monitors can synchronize the ballotbox ledger and add assurances that way.\n\n\n\n\n\n","category":"module"},{"location":"audittools/#PeaceFounder.AuditTools.BallotBoxArchive","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.BallotBoxArchive","text":"struct BallotBoxArchive\n    proposal::Proposal\n    seed::Digest\n    ledger::Vector{CastRecord}\nend\n\nRepresents a ballotbox ledger archive. Contains a proposal for which votes have been collected;  seed initialized by collector and ledger containing all cast records.\n\n\n\n\n\n","category":"type"},{"location":"audittools/#PeaceFounder.AuditTools.BraidChainArchive","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.BraidChainArchive","text":"struct BraidChainArchive\n    ledger::Vector{Transaction}\nend\n\nRepresents a braidchain ledger archive. \n\n\n\n\n\n","category":"type"},{"location":"audittools/#PeaceFounder.AuditTools.archive","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.archive","text":"archive(ledger::BraidChain)::BraidChainArchive\narchive(ledger::BallotBox)::BallotBoxArchive\n\nForm an archive of braidchain or ballotbox which can be sent over wire to be audited. \n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit","text":"audit(archive::BallotBoxArchive, spec::CryptoSpec)\n\nCheck that recorded votes are consistent with proposal ballot and that cryptographic signature  of every recorded vote is correct.  â€“-\n\naudit(archive::BraidChainArchive)\n\nCheck that the braidchain ledger is consistent. Runs through \n\n- [`audit_members`](@ref)\n- [`audit_braids`](@ref) \n- [`audit_proposals`](@ref)\n- [`audit_roster`](@ref)\n- [`audit_lots`](@ref)\n\n\n\naudit(ballotbox_archive::BraidChainArchive, ballotbox_archive::BallotBoxArchive, hasher)\n\nAudits each ledger seperatelly and then checks consistency between themselves: such as that only valid member pseudonyms have cast their votes, that proposal is available in the braidchain ledger.\n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit_braids","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit_braids","text":"audit_braids(ledger::BraidChainArchive)\n\nIndividually check every braid and it's zero knowledge proof and it's consistency with the chain.  For the latter, that input pseudonyms and relative generator to a braid come from a previous output  braiding output and newly registered members. \n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit_lots","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit_lots","text":"audit_lots(ledger::BraidChainArchive)\n\nCheck integrity correct nonce commitments. Note that it is possible that this will be moved out  to a ballotbox ledger in the future. Also service like DRAND would be beneficial to reduce trust assumptions.\n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit_members","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit_members","text":"audit_members(ledger::BraidChainArchive)\n\nCheck every member registration certificate consistency with the ledger. In particular:     - Admission approved by a trusted entity at that time;     - Member approved by a admitted identity only once;     - Every member psuedonym is generated with the current relative generator in the braidchain ledger;\n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit_proposals","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit_proposals","text":"audit_proposals(ledger::BraidChainArchive)\n\nCheck every proposal for it's consistency with the chain. In particular:     - Every proposal is signed by a valid proposer at the time of inclusion in the ledger;     - Anchor in within the proposal is consistent with the ledger;      - Every proposal has a unique UUID as well as it's title is        sufficiently different from previous ones;\n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.audit_roster","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.audit_roster","text":"audit_roster(ledger::BraidChainArchive)\n\nCheck that every DemeSpec transaction in the ledger is correctly signed by the guardian.  \n\n\n\n\n\n","category":"function"},{"location":"audittools/#PeaceFounder.AuditTools.checksum","page":"PeaceFounder.AuditTools","title":"PeaceFounder.AuditTools.checksum","text":"checksum(ledger::Union{BraidChainArchive, BallotBoxArchive}, hasher)::Digest\n\nCalculate a history tree root from a given ledger records. Meant to be used to check integrity of the received data. \n\n\n\n\n\n","category":"function"},{"location":"overview/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The foundation of the peacefounder system is an opportunity to issue digital signatures with the same private key for different relative generators without sacrificing key security. The signatures in such cases are supplemented by different public keys. They are not relatable to each other unless someone provides a mapping exponent between relative generators or a zero-knowledge proof of discrete logarithm equality. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"This unlinkability can be used to link multiple private keys together in a knot-like structure so that input pseudonyms public keys obtained through exponentiating relative generators with private keys are related to output pseudonyms while remaining unlikable if we have a trusted dealer who exponentiates relative generator and pseudonyms with the same secret exponential factor and shuffles the output pseudonyms in the result. We shall call this procedure braiding and the one who does it a braider for convenience and to distinguish that from mix and mixing. The input and output relative generator and pseudonyms form a knot-like primitive we shall call a braid. The output relative generator then can be used to issue signatures on the messages which are unlinkable to the input pseudonyms while they are in the eligibility set of output pseudonyms which are ideally applicable for voting.","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A zero-knowledge proof of shuffle and decryption can be used to eliminate the assumption of a trusted dealer and prove that braids have been computed honestly without spoiling or replacing output pseudonyms with braider's variants. The zero-knowledge proof of shuffle has been successfully made widely available for ElGamal re-encryption with Verificatum, which offers proof with relatively standard cryptographic assumptions:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Discrete Logarithm problem hard\nDecisional Diffie Hellman problem hard ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Combining Verificatum proof of shuffle with proof of decryption, it is possible to form a braid proof which proves to everyone that outputs have been obtained from inputs without revealing the secret exponentiation factor braider used, which can be forgotten after the proof is finished. The resulting braid primitive is available in the ShuffleProofs.jl package, which also reimplements Verificatum-compatible proof of shuffle. ","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"The braid primitive...","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"To be continued...","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"A more detailed diagram:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"(Image: )","category":"page"},{"location":"schedulers/#PeaceFounder.Schedulers","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers","text":"","category":"section"},{"location":"schedulers/","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers","text":"Modules = [PeaceFounder.Schedulers]\nOrder = [:type, :function]","category":"page"},{"location":"schedulers/#PeaceFounder.Schedulers.Scheduler","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers.Scheduler","text":"mutable struct Scheduler\n    condition::Condition\n    pool_interval::Union{Int, Nothing}\n    retry_interval::Union{Int, Nothing}\n    delay::Int\n    started::Bool\n    finished::Bool\n    schedule::Vector{Tuple{DateTime, <:Any}}\nend\n\nRepresents a waitable object which resumes at predetermined scheduled times. A typical use for it  is in the event loop like:\n\nscheduler = Scheduler(; retry_interval = 1)\n\nlock(scheduler) do \n    schedule!(scheduler, now() + Second(1), value)\nend\n\nwhile true\n    value = wait(scheduler)\n    try\n        # Do some stuff\n    catch\n        retry!(scheduler)\n    end\nend\n\nIn the event loop one manages a state machine which can succed and fail. If it succeds a scheduled time is taken out from the scheduler and proceeds waiting the next event. In the case event at scheduled time had failed the scheduler is notified with retry! method and attempts to run the event loop againafter retry_interval until succeeds. \n\n\n\n\n\n","category":"type"},{"location":"schedulers/#Base.lock-Tuple{PeaceFounder.Schedulers.Scheduler}","page":"PeaceFounder.Schedulers","title":"Base.lock","text":"lock(scheduler::Scheduler)\n\nLock a scheduler. This is necessary to avoid simultanous modifications of the schedule field. Note that other Scheduler fields are not protected with the lock as thoose are considered internal. \n\n\n\n\n\n","category":"method"},{"location":"schedulers/#Base.notify-Tuple{PeaceFounder.Schedulers.Scheduler}","page":"PeaceFounder.Schedulers","title":"Base.notify","text":"notify(scheduler::Scheduler[, value])\n\nNotify a scheduler with a value which is returned at wait.\n\n\n\n\n\n","category":"method"},{"location":"schedulers/#Base.wait-Tuple{PeaceFounder.Schedulers.Scheduler}","page":"PeaceFounder.Schedulers","title":"Base.wait","text":"wait(scheduler::Scheduler)\n\nWait until next event is reached and return it's value. In the case event have run through  smoothelly the scheduler event is droped with the next wait call. See also retry! method.\n\n\n\n\n\n","category":"method"},{"location":"schedulers/#PeaceFounder.Schedulers.next_event-Tuple{PeaceFounder.Schedulers.Scheduler}","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers.next_event","text":"next_event(scheduler::Scheduler)\n\nReturn the next event in seconds and coresponding event value. Return nothing if  no events are scheduled.\n\n\n\n\n\n","category":"method"},{"location":"schedulers/#PeaceFounder.Schedulers.retry!-Tuple{PeaceFounder.Schedulers.Scheduler}","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers.retry!","text":"retry!(scheduler::Scheduler)\n\nNotifies the scheduler that event have run unsucesfully which reschedules it after specified retry_time(See Scheduler). \n\n\n\n\n\n","category":"method"},{"location":"schedulers/#PeaceFounder.Schedulers.schedule!-Tuple{PeaceFounder.Schedulers.Scheduler, Dates.DateTime, Any}","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers.schedule!","text":"schedule!(scheduler::Scheduler, timestamp::DateTime[, value])\n\nSchedule an event at timestamp with a provided value. To avoid messing up a schedule acquire  a scheduler's lock before adding the event as:\n\nlock(scheduler) do\n    schedule!(scheduler, now() + Second(1), value)\nend\n\n\n\n\n\n","category":"method"},{"location":"schedulers/#PeaceFounder.Schedulers.waituntil-Tuple{Dates.DateTime}","page":"PeaceFounder.Schedulers","title":"PeaceFounder.Schedulers.waituntil","text":"waituntil(time::DateTime)\n\nWaits until given time is reached. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"","category":"section"},{"location":"model_api/#Primitives","page":"PeaceFounder.Model","title":"Primitives","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"Modules = [PeaceFounder.Model]\nOrder = [:type, :function]\nPages = [\"Model/crypto.jl\", \"Model/seal.jl\"]","category":"page"},{"location":"model_api/#PeaceFounder.Model.AckConsistency","page":"PeaceFounder.Model","title":"PeaceFounder.Model.AckConsistency","text":"struct AckConsistency{T}\n    proof::ConsistencyProof\n    commit::Commit{T}\nend\n\nRepresents an ackknowledgment from the issuer that a root is permanetly included in the ledger. This acknowledgemnt assures that ledger up to index(ack) is included in the current ledger which has has index index(commit(ack)). This is useful in a combination with AckInclusion to privatelly update it's validity rather than asking an explicit element. Also ensures that other elements in the ledger are not being tampered with.\n\nInterface: root, id, issuer, commit, index, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.AckInclusion","page":"PeaceFounder.Model","title":"PeaceFounder.Model.AckInclusion","text":"struct AckInclusion{T}\n    proof::InclusionProof\n    commit::Commit{T}\nend\n\nRepresents an acknowldgment from the issuer that a leaf is permanently included in the ledger.  In case the ledger is tampered with this acknowledgement acts as sufficient proof to blame the issuer.\n\nInterface: leaf, id, issuer, commit, index, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Commit","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Commit","text":"Commit{T}\n    state::T\n    seal::Seal\nend\n\nRepresents a commited ledger state to which issuer can be held accountable for integrity. It is assumed that T implements index and root necessaary to fix a ledger state. \n\nInterface: id, issuer, verify, index, root, state\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.CryptoSpec","page":"PeaceFounder.Model","title":"PeaceFounder.Model.CryptoSpec","text":"struct CryptoSpec\n    hasher::Hash\n    group::Spec\n    generator::Generator\nend\n\nSpecification of cryptographic parameters which are used for public key cryptography, message hashing and authetification codes. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Digest","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Digest","text":"struct Digest\n    data::Vector{UInt8}\nend\n\nA message digest obtained applying a hash function on a message or a document. See method digest.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Generator","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Generator","text":"struct Generator\n    data::Vector{UInt8}\nend\n\nDatatype which stores cryptogrpahic group point in standart octet form intended to be used as a base. See also Pseudonym.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.HMAC","page":"PeaceFounder.Model","title":"PeaceFounder.Model.HMAC","text":"struct HMAC\n    key::Vector{UInt8}\n    hasher::Hash\nend\n\nRepresent a hash message authetification code authorizer.\n\nInterface: hasher, digest, key\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Hash","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Hash","text":"struct Hash\n    spec::String\nend\n\nA specification for a hasher. See method digest.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Pseudonym","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Pseudonym","text":"struct Pseudonym\n    pk::Vector{UInt8}\nend\n\nA datatype which stores public key in canonical standart octet form.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Seal","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Seal","text":"struct Seal\n    pbkey::Pseudonym\n    sig::Signature\nend\n\nA wrapper type for a signature which adds a public key of signature issuer. See seal method. \n\nInterface: pseudonym, verify\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Signer","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Signer","text":"struct Signer\n    spec::CryptoSpec\n    pbkey::Pseudonym\n    key::BigInt\nend\n\nA signer type. See a method generate(Signer, spec) for initialization.\n\nInterface: pseudonym, id, sign, seal, approve\n\n\n\n\n\n","category":"type"},{"location":"model_api/#HistoryTrees.leaf-Tuple{PeaceFounder.Model.AckInclusion}","page":"PeaceFounder.Model","title":"HistoryTrees.leaf","text":"leaf(ack::AckInclusion)\n\nAccess a leaf diggest for which the acknowledgment is made.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.root-Tuple{PeaceFounder.Model.AckConsistency}","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(x::AckConsistency)\n\nAccess a root diggest for which the acknowledgment is made.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.root-Tuple{PeaceFounder.Model.Commit}","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(x)::Digest\n\nReturn a ledger root hash.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit-Tuple{PeaceFounder.Model.AckInclusion}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(x)\n\nAccess a commit of an object x. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.digest-Tuple{Any, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.digest","text":"digest(message::Vector{UInt8}, hasher::Hash)::Digest\ndigest(document, spec) = digest(canonicalize(message)::Vector{UInt8}, hasher(spec)::Hash)\n\nReturn a resulting digest applying hasher on the given message. When message is not octet string a canonicalize method is applied first.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.digest-Tuple{Vector{UInt8}, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.digest","text":"digest(bytes::Vector{UInt8}, hasher::Hash)::Digest\ndigest(x, spec) = digest(canonicalize(x)::Vector{UInt8}, hasher(spec)::Hash)\n\nCompute a hash digest. When input is not in bytes the canonicalize method is applied first.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generate-Tuple{Type{PeaceFounder.Model.Signer}, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generate","text":"generate(Signer, spec::CryptoSpec)::Signer\n\nGenerate a unique private key and return a Signer object. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(crypto::CryptoSpec)::Generator\n\nReturn a generator of the specification. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{Union{CryptoGroups.Specs.ECP, CryptoGroups.Specs.EC2N, CryptoGroups.Specs.Koblitz}}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(spec::Spec)::Generator\n\nReturn a generator of spec.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.hasher-Tuple{PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.hasher","text":"hasher(spec)::Hash\n\nAccess a hasher function from a given specification.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.index-Tuple{PeaceFounder.Model.AckConsistency}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(ack::AckConsistency)\n\nReturn an index for a root at which the consistency proof is made. To obtain the current ledger index use index(commit(ack)).\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.index-Tuple{PeaceFounder.Model.AckInclusion}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(ack::AckInclusion)::Int\n\nReturn an index at which the leaf is recorded in the ledger. To obtain the current ledger index use index(commit(ack)).\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.index-Tuple{PeaceFounder.Model.Commit}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(x)::Int\n\nReturn an index of a ledger state.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{Any, Any, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(x, y, spec::Hash)::Bool\nisbinding(x, y, spec) = isbinding(x, y, hasher(spec)::Hash)\n\nCheck binding of two objects x and y. Some general examples:\n\nCheck that a document is bound to it's signature. \nCheck that a record is included in the ledger.\nCheck that a given object is consistent with a ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.issuer-Tuple{PeaceFounder.Model.Commit}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.issuer","text":"issuer(x)\n\nIn case an object x is cryptographically signed return an issuer of who have issued the signature. See also id.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.key-Tuple{PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.key","text":"key(x)\n\nAccess a secret key of an object x.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.seal-Tuple{Vector{UInt8}, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.seal","text":"seal(message::Vector{UInt8}[, generator::Generator], signer::Signer)::Seal\n\nSign a bytestring message with signer's private key and specification and return a signature as a Seal. When generator is provided it is used as  a base for the signature. See also sign.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.sign-Tuple{PeaceFounder.Model.Digest, PeaceFounder.Model.Generator, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.sign","text":"sign(digest::Digest[, generator::Generator], signer::Signer)::Signature\n\nSign a digest as an integer with signer's private key and specification. This method avoids  running hashing twice when that is done externally. When generator is provided it is used as  a base for the signature.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.sign-Tuple{Vector{UInt8}, PeaceFounder.Model.Generator, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.sign","text":"sign(message::Vector{UInt8}[, generator::Generator], signer::Signer)::Signature\n\nSign a bytestring message with signer's private key and specification. When generator is provided it is used as  a base for the signature.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.state-Tuple{PeaceFounder.Model.Commit}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.state","text":"state(commit::Commit{T})::T\n\nReturn a ledger state. T implements index and root. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.canonicalize","page":"PeaceFounder.Model","title":"PeaceFounder.Model.canonicalize","text":"ToDo: a well specified encoding is essential here. Binary tree encoding may suffice here. More fancy approach would be to use a DER encoding. Meanwhile JSON shall be used.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.pseudonym","category":"page"},{"location":"model_api/#PeaceFounder.Model.pseudonym","page":"PeaceFounder.Model","title":"PeaceFounder.Model.pseudonym","text":"pseudonym(signer::Signer, [generator])::Pseudonym\n\nReturn a pseudonym of a signer at a given relative generator. If generator is not passed returns identity pseudonym. (See also id)\n\n\n\npseudonym(seal::Seal)::Pseudonym\n\nReturn a pseudonym of a seal. Note that it is not equal to identity when the signature is issued on a relative generator.\n\n\n\npseudonym(vote::Vote)::Pseudonym\n\nReturn a pseudonym used to seal the vote.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.id","category":"page"},{"location":"model_api/#PeaceFounder.Model.id","page":"PeaceFounder.Model","title":"PeaceFounder.Model.id","text":"id(document)::Pseudonym\n\nReturn identity pseudonym of a document issuer.\n\n\n\nid(signer)::Pseudonym\n\nReturn identity pseudonym of a signer.\n\n\n\n\n\n","category":"function"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"PeaceFounder.Model.verify","category":"page"},{"location":"model_api/#PeaceFounder.Model.verify","page":"PeaceFounder.Model","title":"PeaceFounder.Model.verify","text":"verify(message, seal::Seal, [generator::Generator], crypto::CryptoSpec)::Bool\nverify(message, pk::Pseudonym, sig::Signature, [generator::Generator], crypto::CryptoSpec)::Bool\n\nVerify the cryptographic signature of the message returning true if valid.  An optional generator can be given when signature is issued on  a relative generator differing from a base specification crypto. \n\n\n\nverify(document[, generator::Generator], crypto::CryptoSpec)::Bool\n\nVerify a cryptographic signature of the document returning true if valid. \n\n\n\nverify(braidwork::BraidWork, crypto::CryptoSpec)::Bool\n\nVerify a braider issued cryptographic signature for the braidwork and a zero knowledge proofs. Returns true if both checks succeed.\n\n\n\n\n\n","category":"function"},{"location":"model_api/#Admission","page":"PeaceFounder.Model","title":"Admission","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"Modules = [PeaceFounder.Model]\nOrder = [:type, :function]\nPages = [\"Model/admissions.jl\"]","category":"page"},{"location":"model_api/#PeaceFounder.Model.Admission","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Admission","text":"struct Admission\n    ticketid::TicketID\n    id::Pseudonym\n    timestamp::DateTime\n    approval::Union{Seal, Nothing}\nend\n\nRepresents an admission certificate for a pseudonym id. \n\nInterface: approve, issuer, id, ticket, isadmitted\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Ticket","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Ticket","text":"mutable struct Ticket\n    const ticketid::TicketID\n    timestamp::DateTime\n    salt::Vector{UInt8}\n    auth_code::Digest\n    token::Digest\n    admission::Union{Admission, Nothing}\nend\n\nRepresents a ticket state for ticket with ticketid. timestamp represents time when the ticket have been issued by a recruiter client in authorization system of choice, for instance, Recruiters.jl; salt contains a random bytestring generated by the server from which the reccruiter client can derive a token as token(ticketid, salt, hmac). auth_code is a server generated authetification code for a given salt and current metadata. Lastly admission contains a certified member pseudonym which was authetificated by the user with token.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.TicketID","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TicketID","text":"struct TicketID\n    id::Vector{UInt8}\nend\n\nRepresents a unique identifier for which a recruit tooken is issued. In case of necessity id can contain a full document, for instance, registration form, proof of identity and etc. In case a privacy is an issue the id can contain a unique identifier which can be matched to an identity in an external database.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.TicketStatus","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TicketStatus","text":"struct TicketStatus     ticketid::TicketID     timestamp::DateTime     admission::Union{Nothing, Admission} end\n\nRepresents a public state of a ticket. See ticket_status and isadmitted methods. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.TokenRecruiter","page":"PeaceFounder.Model","title":"PeaceFounder.Model.TokenRecruiter","text":"struct TokenRecruiter\n    metadata::Ref{Vector{UInt8}} \n    tickets::Vector{Ticket}\n    signer::Signer\n    hmac::HMAC\nend\n\nRepresents a state for token recruiter service. To initialize the service it's necessary to create a signer who can issue a valid admisssion certificates and a secret key with which a recruit client can exchange authorized messages. See also method generate(TokenRecruiter, spec).\n\nMetadata is used as means to securelly deliver to the client most recent server specification. \n\nInterface: select, hmac, hasher, key, id, tickets, in, set_metadata!, enlist!, admit!, isadmitted, ticket_status\n\n\n\n\n\n","category":"type"},{"location":"model_api/#Base.in-Tuple{PeaceFounder.Model.TicketID, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"Base.in","text":"in(ticketid::TicketID, recruiter::TokenRecruiter)::Bool\n\nReturn true if there already is a ticket with ticketid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.admit!-Tuple{PeaceFounder.Model.TokenRecruiter, PeaceFounder.Model.Pseudonym, PeaceFounder.Model.TicketID, PeaceFounder.Model.Digest}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.admit!","text":"admit!(recruiter::TokenRecruiter, id::Pseudonym, ticketid::TicketID, auth_code::Digest)::Admission\n\nAttempt to admit an identity pseudonym id for ticket ticketid with provided authorization code. This function retrieves a ticket with given ticketid and uses it's recorded token to check whether the request is binding. In the case of success an admnission certificate is formed with provided indenty pseudonym id and is signed by the recruter's private key. Otherwise when either of checks fail an error is raised. In the case ticket is already addmitted, returns previously stored admission. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.approve-Tuple{PeaceFounder.Model.Admission, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.approve","text":"approve(x::T, signer::Signer)::T\n\nCryptographically sign a document x::T and returns a signed document with the same type. To check whether a document is signed see issuer method.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.auth-Tuple{PeaceFounder.Model.Pseudonym, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.auth","text":"auth(id::Pseudonym, hmac::HMAC)::Digest\nauth(id::Pseudonym, token::Digest, hasher::Hash) = auth(id, HMAC(bytes(token), hasher))\n\nCompute a hash authorization code for identity pseudonym using token as a key. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.auth-Tuple{PeaceFounder.Model.TicketID, Dates.DateTime, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.auth","text":"auth(ticketid::TicketID, time::DateTime, hmac::HMAC)::Digest\n\nCompute a hash authorization code for ticketid at given time. The message needs to reach token recruiter within a 60 second window before it is obseleted.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.auth-Tuple{Vector{UInt8}, PeaceFounder.Model.TicketID, Vector{UInt8}, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.auth","text":"auth(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)::Digest\n\nCompute a hash authorization code for a metadata, salt from which a token is derived. Metadata can be configured to contain most recent server specification DemeSpec; ticketid takes session identifier role.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.enlist!-Tuple{PeaceFounder.Model.TokenRecruiter, PeaceFounder.Model.TicketID, Dates.DateTime, PeaceFounder.Model.Digest}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.enlist!","text":"enlist!(recruiter::TokenRecruiter, ticketid::TicketID, timestamp::DateTime, ticket_auth_code::Digest)::Tuple{Vector{UInt8}, Vector{UInt8}, Digest}\n\nAttempt to enlist a ticket with given ticketid authetificated by a recruit client at timestmap. This function checks the age of the request which need to be less than 60 seconds to be considered. Then the hash authorization code is checked after which a triplet of metadata, salt and reply_auth_code is returned. If either of theses checks fail an error is raised and needs to be dealt by the user. See a token method on how the token is derived.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generate-Tuple{Type{PeaceFounder.Model.TokenRecruiter}, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generate","text":"generate(TokenRecruiter, spec::CryptoSpec)\n\nGenerate a new token recruiter with unique signer and athorization key.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.hmac-Tuple{PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.hmac","text":"hmac(x)::HMAC\n\nReturn HMAC authorizer from a given object.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isadmitted-Tuple{PeaceFounder.Model.TicketID, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isadmitted","text":"isadmitted(ticketid::TicketID, recruiter::TokenRecruiter)\n\nCheck whether a ticket is already admitted. Returns false when either ticket is nonexistent or it's admission is nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isadmitted-Tuple{PeaceFounder.Model.TicketStatus}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isadmitted","text":"isadmitted(status::TicketStatus)\n\nCheck whether ticket is addmitted. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.Pseudonym, PeaceFounder.Model.Digest, PeaceFounder.Model.Digest, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(id::Pseudonym, auth_code::Digest, token::Digest, hasher::Hash)\n\nCheck whether a request for a new identity pseudonym admission is authetificated. The token is delivered to a user by recruit client.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.TicketID, Dates.DateTime, PeaceFounder.Model.Digest, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(ticketid::TicketID, timestamp::DateTime, auth_code::Digest, hmac::HMAC)\n\nCheck whether request for a new ticketid is authorized by recruit client. Note that freshness of the request  is not considered within this method.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{Vector{UInt8}, PeaceFounder.Model.TicketID, Vector{UInt8}, PeaceFounder.Model.Digest, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(metadata::Vector{UInt8}, ticketid::TicketID, salt::Vector{UInt8}, auth_code::Digest, hmac::HMAC)\n\nCheck whether a reply for a new ticketid is authorized by the recruit server. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.select-Tuple{Type{PeaceFounder.Model.Admission}, PeaceFounder.Model.Pseudonym, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.select","text":"select(Admission, ticketid::TicketID, recruiter::TokenRecruiter)::Union{Admission, Nothing}\n\nReturn admission for a ticket with given a given identity pseudonym from recruiter. If no ticket with given id is found OR ticket is not yet admitted returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.select-Tuple{Type{PeaceFounder.Model.Admission}, PeaceFounder.Model.TicketID, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.select","text":"select(Admission, ticketid::TicketID, recruiter::TokenRecruiter)::Union{Admission, Nothing}\n\nReturn admission for a ticket with given ticketid from recruiter. If no ticket with given ticketid is found OR ticket is not yet admitted returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.select-Tuple{Type{PeaceFounder.Model.Ticket}, Function, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.select","text":"select(T, predicate::Function, recruiter::TokenRecruiter)::Union{T, Nothing}\n\nFrom a list of all recruiter tickets return T <: Union{Ticket, Admission} for which predicate is true. If none succeds returns nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.set_metadata!-Tuple{PeaceFounder.Model.TokenRecruiter, Vector{UInt8}}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.set_metadata!","text":"set_metadata!(recruiter::TokenRecruiter, metadata::Vector{UInt8})\n\nReplace metadata for a recruiter. Note when data is replaced all unfinalized tokens need to be flushed. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ticket-Tuple{PeaceFounder.Model.Admission}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ticket","text":"ticket(x::Admission)\n\nReturn a TicketID which is admitted.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ticket_status-Tuple{PeaceFounder.Model.TicketID, PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ticket_status","text":"ticket_status(ticketid::TicketID, recruiter::TokenRecruiter)::Union{TicketStatus, Nothing}\n\nReturn a ticket status for a ticketid. In case ticket is not found return nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.tickets-Tuple{PeaceFounder.Model.TokenRecruiter}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.tickets","text":"tickets(recruiter::TokenRecruiter)::Vector{TicketID}\n\nReturn a list of registered ticket ids. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.token-Tuple{PeaceFounder.Model.TicketID, Vector{UInt8}, PeaceFounder.Model.HMAC}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.token","text":"token(ticketid::TicketID, salt::Vector{UInt8}, hmac::HMAC)\n\nCompute a recruit token for a given ticket with provided salt. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#BraidChain","page":"PeaceFounder.Model","title":"BraidChain","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"Modules = [PeaceFounder.Model]\nOrder = [:type, :function]\nPages = [\"Model/braidchains.jl\", \"Model/braids.jl\"]","category":"page"},{"location":"model_api/#PeaceFounder.Model.BraidChain","page":"PeaceFounder.Model","title":"PeaceFounder.Model.BraidChain","text":"struct BraidChain\n    members::Set{Pseudonym}\n    ledger::Vector{Transaction}\n    spec::DemeSpec\n    generator::Generator\n    tree::HistoryTree\n    commit::Union{Commit{ChainState}, Nothing}\nend\n\nRepresents a braidchain ledger with it's associated state. Can be instantitated with a demespec file using BraidChain(::DemeSpec) method.\n\nInterface:  push!, record!, state, length, list, select, roll, constituents, generator, commit, commit_index, ledger, leaf, root, ack_leaf, ack_root, members, commit!\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.ChainState","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ChainState","text":"struct ChainState\n    index::Int\n    root::Digest\n    generator::Generator\n    member_count::Int\nend\n\nRepresents a chain state metadata which is sufficient for integrity checks.\n\nInterface: index, root, generator\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.DemeSpec","page":"PeaceFounder.Model","title":"PeaceFounder.Model.DemeSpec","text":"struct DemeSpec <: Transaction\n    uuid::UUID\n    title::String\n    crypto::CryptoSpec\n    guardian::Pseudonym\n    recorder::Pseudonym\n    recruiter::Pseudonym\n    braider::Pseudonym\n    proposer::Pseudonym \n    collector::Pseudonym\n    timestamp::Union{DateTime, Nothing} = nothing\n    signature::Union{Signature, Nothing} = nothing\nend\n\nRepresents a deme configuration parameters issued by the guardian.\n\nuuid::UUID an unique random generated community identifier;\ntitle::String a community name with which deme is represented;\ncrypto::CryptoSpec cryptographic parameters for the deme;\nguardian::Pseudonym an issuer for this demespec file. Has authorithy to set a roster:\nrecorder::Pseudonym an authorithy which has rights to add new transactions and is responsable for braidchain's ledger integrity. Issues Commit{ChainState};\nrecruiter::Pseudonym an authorithy which has rights to authorize new admissions to the deme. See Admission and Member;\nbraider::Pseudonym an authorithy which can do a legitimate braid jobs for other demes. See BraidWork;   \nproposer::Pseudonym an authorithy which has rights to issue a proposals for the braidchain. See Proposal;\ncollector::Pseudonym an authorithy which is repsonsable for collecting votes for proposals. This is also recorded in the proposal itself.\ntimestamp::Union{DateTime, Nothing} time when signature is being issued;\nsignature::Union{Signature, Nothing} a guardian issued signature. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Member","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Member","text":"struct Member <: Transaction\n    admission::Admission\n    generator::Generator\n    pseudonym::Pseudonym\n    approval::Union{Signature, Nothing} \nend\n\nA new member certificate which rolls in (anouances) it's pseudonym at current generator signed with identity pseudonym certified with admission certificate issued by registrar. This two step process is necessary as a checkpoint in situations when  braidchain ledger get's locked during a new member resgistration procedure.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Transaction","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Transaction","text":"Transaction\n\nRepresents an abstract record type which can be stored in the braidchain ledger. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#Base.push!-Tuple{PeaceFounder.Model.BraidChain, PeaceFounder.Model.Transaction}","page":"PeaceFounder.Model","title":"Base.push!","text":"push!(ledger::BraidChain, t::Transaction)\n\nAdd an element to the BraidChain bypassing transaction verification with the chain. This should only be used when the ledger is loaded from a trusted source like a local disk or when final root hash is validated with a trusted source.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.leaf-Tuple{PeaceFounder.Model.BraidChain, Int64}","page":"PeaceFounder.Model","title":"HistoryTrees.leaf","text":"leaf(ledger::BraidChain, N::Int)::Digest\n\nReturn a ledger's element digest at given index.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.root-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(ledger::BraidChain[, N::Int])::Digest\n\nReturn a ledger root digest. In case when index is not given a current index is used.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_leaf-Tuple{PeaceFounder.Model.BraidChain, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_leaf","text":"ack_leaf(ledger::BraidChain, index::Int)::AckInclusion\n\nReturn a proof for record inclusion with respect to a current braidchain ledger history tree root. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_root-Tuple{PeaceFounder.Model.BraidChain, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_root","text":"ack_root(ledger::BraidChain, index::Int)\n\nReturn a proof for the ledger root at given index with respect to the current braidchain ledger history tree root.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.approve-Tuple{PeaceFounder.Model.Member, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.approve","text":"approve(member::Member, signer::Signer)::Member\n\nSign a member certificate and return it with approval field filled.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit!-Tuple{PeaceFounder.Model.BraidChain, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit!","text":"commit!(ledger::BraidChain, signer::Signer)\n\nCommit a current braidchain ledger state with a signer's issued cryptographic signature. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(ledger::BraidChain)\n\nReturn a current commit for a braichain. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.constituents-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.constituents","text":"constituents(ledger::BraidChain)::Set{Pseudonym}\n\nReturn all member identity pseudonyms. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.BraidChain, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(ledger[, index])\n\nReturn a generator at braidchain ledger row index. If index is omitted return the current state value.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(ledger::BraidChain)\n\nReturn a current relative generator for a braidchain ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.Member}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(member::Member)::Generator\n\nGenerator at which member tries to roll in the braidchain.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.id-Tuple{PeaceFounder.Model.Member}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.id","text":"id(member::Member)::Pseudonym\n\nIdentity pseudonym for a member. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.Admission, PeaceFounder.Model.DemeSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(admission::Admission, spec::DemeSpec)\n\nCheck whether issuer of admission is a recruiter set in spec.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.Transaction, PeaceFounder.Model.AckInclusion{PeaceFounder.Model.ChainState}, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(record::Transaction, ack::AckInclusion{ChainState}, crypto::CryptoSpec)\n\nA generic method checking whether transaction is included in the braidchain.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.issuer-Tuple{PeaceFounder.Model.Member}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.issuer","text":"issuer(member::Member)::Pseudonym\n\nThe identiy of registrar who signed admission.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.list-Union{Tuple{T}, Tuple{Type{T}, PeaceFounder.Model.BraidChain}} where T<:PeaceFounder.Model.Transaction","page":"PeaceFounder.Model","title":"PeaceFounder.Model.list","text":"list(T, ledger::BraidChain)::Vector{Tuple{Int, T}}\n\nList braidchain elements with a given type together with their index.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.members-Tuple{PeaceFounder.Model.BraidChain, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.members","text":"members(ledger::BraidChain[, index::Int])::Set{Pseudonym}\n\nReturn a set of member pseudonyms at relative generator at braidchain ledger row index. If index is omitted return a current state value.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.pseudonym-Tuple{PeaceFounder.Model.Member}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.pseudonym","text":"pseudonym(member::Member)::Pseudonym\n\nPseudonym for a member at the generator(member). \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.reset_tree!-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.reset_tree!","text":"reset_tree!(ledger::BraidChain)\n\nRecompute a chain tree hash. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.roll-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.roll","text":"roll(ledger::BraidChain)::Vector{Member}\n\nReturn all member certificates from a braidchain ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.select-Union{Tuple{T}, Tuple{Type{T}, Function, PeaceFounder.Model.BraidChain}} where T<:PeaceFounder.Model.Transaction","page":"PeaceFounder.Model","title":"PeaceFounder.Model.select","text":"select(T, predicate::Function, ledger::BraidChain)::Union{T, Nothing}\n\nReturn a first element from a ledger with a type T which satisfies a predicate. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.state-Tuple{PeaceFounder.Model.BraidChain}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.state","text":"state(ledger::BraidChain)\n\nReturn a current braidchain ledger state metadata.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ticket-Tuple{PeaceFounder.Model.Member}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ticket","text":"ticket(member::Member)\n\nTicket for a member admission certificate.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.BraidWork","page":"PeaceFounder.Model","title":"PeaceFounder.Model.BraidWork","text":"struct BraidWork <: Transaction\n    braid::Simulator\n    consumer::DemeSpec\n    producer::DemeSpec\n    approval::Union{Seal, Nothing}\nend\n\nRepresents a braider's computation which is supported with zero knowledge proof of shuffle and decryption assuring it's corectness stored in a braid field; consumer denotes a deme for which the braid is intended and producer denotes a deme where  the braid is made. To assert latter the the braider signs the braidwork and stores that in the aproval field. See a braid method.\n\nInterface: approve, verify, input_generator, input_members, output_generator, output_members\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.approve-Tuple{PeaceFounder.Model.BraidWork, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.approve","text":"approve(braid::BraidWork, braider::Signer)\n\nSign a braidwork with a braider. Throws an error if braider is not in the producer demespec.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.braid-Tuple{PeaceFounder.Model.Generator, Union{Set{PeaceFounder.Model.Pseudonym}, Vector{PeaceFounder.Model.Pseudonym}}, PeaceFounder.Model.DemeSpec, PeaceFounder.Model.DemeSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.braid","text":"braid(generator::Generator, members::Union{Vector{Pseudonym}, Set{Pseudonym}}, consumer::DemeSpec, producer::DemeSpec; verifier = (g) -> ProtocolSpec(; g))\n\nSelects a private exponent x at random and computes a new generator g = g^x and member_i=member_i^x  returns the latter in a sorted order and provides a zero knowledge proof that all operations have been performed honestly.  In partucular, not including/droping new member pseudonyms in the process. consumer attributes are necessary to  interepret generator and pseudonym group elements with which the computation is performed. \n\nBy default a Verificatum compatable verifier is used for performing reencryption proof of shuffle\n\nA verifier can be configured with a keyword argument. By default a Verificatum compatable verifier for a proof of shuffle is used.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.input_generator-Tuple{PeaceFounder.Model.BraidWork}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.input_generator","text":"input_generator(braid::BraidWork)\n\nReturn input generator of the braid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.input_members-Tuple{PeaceFounder.Model.BraidWork}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.input_members","text":"input_members(braid::BraidWork)\n\nReturn input member pseudonyms of the braid at provided input generator. See input_generator\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.output_generator-Tuple{PeaceFounder.Model.BraidWork}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.output_generator","text":"output_generator(braid::BraidWork)\n\nReturn output genertor of the braid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.output_members-Tuple{PeaceFounder.Model.BraidWork}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.output_members","text":"output_members(braid::BraidWork)\n\nReturn output member pseudonyms of the braid at a resulting output generator. See output_generator\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.verify-Tuple{PeaceFounder.Model.BraidWork, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.verify","text":"verify(braid::BraidWork, crypto::CryptoSpec)\n\nVerifies a braid approval and then it's zero knowledge proofs. A crypto argument is  provided to avoid downgrading attacks. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#Ballot-Box","page":"PeaceFounder.Model","title":"Ballot Box","text":"","category":"section"},{"location":"model_api/","page":"PeaceFounder.Model","title":"PeaceFounder.Model","text":"Modules = [PeaceFounder.Model]\nOrder = [:type, :function]\nPages = [\"Model/proposals.jl\"]","category":"page"},{"location":"model_api/#PeaceFounder.Model.Ballot","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Ballot","text":"struct Ballot\n    options::Vector{String}\nend\n\nRepresents a simple ballot form for multiple choice question. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.BallotBox","page":"PeaceFounder.Model","title":"PeaceFounder.Model.BallotBox","text":"mutable struct BallotBox\n    proposal::Proposal\n    voters::Set{Pseudonym} # better than members\n    collector::Pseudonym\n    seed::Union{Digest, Nothing}\n    crypto::CryptoSpec # on the other hand the inclusion of a vote should be binding enough as it includes proposal hash.\n    queue::Vector{Vote}\n    ledger::Vector{CastRecord}\n    tree::HistoryTree\n    commit::Union{Commit{BallotBoxState}, Nothing}\nend\n\nRepresents a ballot box for a proposal. Contains proposal, a set of eligiable voters a collector who collects the votes and a seed which is selected at random when the voting starts. queue contains a list of valid votes which yet to be comitted to a ledger. A history tree is built on leafs of ledger's receipts (see a receipt method). A commit contains a collector seal on the current ballotbox state. \n\nInterface: reset_tree!, generator, uuid, members, ledger, spine, index, seed, leaf, root, record, receipt, commit, tally, set_seed!, ack_leaf, ack_root, ack_cast, commit_index, commit_state, push!, state, validate, record!, commit!\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.BallotBoxState","page":"PeaceFounder.Model","title":"PeaceFounder.Model.BallotBoxState","text":"struct BallotBoxState\n    proposal::Digest\n    seed::Digest\n    index::Int\n    root::Digest\n    tally::Union{Nothing, Tally} \n    view::Union{Nothing, BitVector} # \nend\n\nRepresents a public ballot box state. Contains an immutable proposal and seed digest; a current ledger index, history tree root. When ellections end a tally is included in the state and a view is added listing all counted votes. Note that the view attribute is important for a client to know whether it's key have leaked and somone lese havbe superseeded it's vote by revoting.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.CastAck","page":"PeaceFounder.Model","title":"PeaceFounder.Model.CastAck","text":"struct CastAck\n    receipt::CastReceipt\n    ack::AckInclusion{BallotBoxState}\nend\n\nRepresents a reply to a voter when a vote have been included in the ballotbox ledger. Contains a receipt and inlcusion acknowledgment. In future would also include a blind signature in the reply for a proof of participation. To receive this reply (with a blind signature in the future) a voter needs to send a vote  which is concealed during ellections and thus tagging votes with blind signatures from reply to monitor  revoting would be as hard as monitoring the submitted votes.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.CastReceipt","page":"PeaceFounder.Model","title":"PeaceFounder.Model.CastReceipt","text":"struct CastReceipt\n    vote::Digest\n    timestamp::DateTime\nend\n\nRepresents a ballotbox ledger receipt which is hashed for a history tree. It's sole purpose is  to assure voters that their vote is included in the ledger while also adding additional metadata  as timestamp and. In contrast to CastRecord it does not reveal  how voter have voted thus can be published during ellections without violating fairness property.  For some situations it may be useful to extend the time until the votes are published as that can  disincentivice coercers and bribers as they would not know whether their coerced vote have been superseeded in revoting. See receipt method for it's construction from a CastRecord.\n\nNote that a blind signature could be commited as H(signature|H(vote)) to avoid tagging the use of pseudonym during ellections while collector could issue only a one blind signature for a voter. Note that members whoose private key could have been stolen could not obtain a valid signature for participation and that could be a good thing!\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.CastRecord","page":"PeaceFounder.Model","title":"PeaceFounder.Model.CastRecord","text":"struct CastRecord\n    vote::Vote\n    timestamp::DateTime\nend\n\nRepresents a ballotbox ledger record. Adds a timestamp when the vote have been recorded. In future, the record will also contain a blind signature with which members could prove to everyone  that they had cast their vote without revealing the link to the vote.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.PollingStation","page":"PeaceFounder.Model","title":"PeaceFounder.Model.PollingStation","text":"struct PollingStation\n    halls::Vector{BallotBox}\n    crypto::CryptoSpec\nend\n\nRepresents a pooling station which hosts ballotbox ledgers for every proposal collector manages. \n\nInterface: add!, ballotbox, record!, commit!, commit, ack_leaf, ack_root, ack_cast, record, receipt, spine, ledger, tally, set_seed!\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Proposal","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Proposal","text":"struct Proposal <: Transaction \n    uuid::UUID\n    summary::String\n    description::String\n    ballot::Ballot\n    open::DateTime\n    closed::DateTime\n    collector::Union{Pseudonym, Nothing} # \n    anchor::Union{ChainState, Nothing}\n    approval::Union{Seal, Nothing} \nend\n\nRepresents a proposal for a ballot specyfing voting window, unique identifier, summary, description. Set's the collector identity which collects votes and issues vote inclusion receipts and is responsable for maintaining the ledger's integrity. The proposal also includes an anchor which sets a relative generator with which members vote anonymously. To be considered valid is signed by proposer authorizing vote to take place.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Selection","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Selection","text":"struct Selection\n    option::Int\nend\n\nRepresents voter's selection for a Ballot form.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Tally","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Tally","text":"struct Tally\n    data::Vector{Int}\nend\n\nRepresent a tally for Ballot form obtained aftert counting multiple voter's Selection forms.\n\n\n\n\n\n","category":"type"},{"location":"model_api/#PeaceFounder.Model.Vote","page":"PeaceFounder.Model","title":"PeaceFounder.Model.Vote","text":"struct Vote\n    proposal::Digest\n    seed::Digest\n    selection::Selection\n    seq::Int\n    approval::Union{Seal, Nothing} \nend\n\nRepresents a vote for a proposal issued by a member. The proposal is stored as hash digest ensuring that member have voted on an untampered proposal. seed contains a randon string issued by collector at the moment when a vote starts to eliminate early voting / shortening a time at which coercers could act uppon. selection contians voter's preference; \n\nseq is a serquence number counting a number of votes at which vote have been approved for a given proposal. It starts at 1 and is increased by one for every single signature made on the proposal. This is an important measure which allows to detect possible leakage of a member's private key. Also provides means for revoting ensuring that latest vote get's counted.\n\nThe vote is considered valid when it is sealed by a member's private key at a relative generator stored in the proposal. \n\n\n\n\n\n","category":"type"},{"location":"model_api/#Base.length-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"Base.length","text":"length(ledger::BallotBox)\n\nReturn a total length of the ledger including uncommited records in the queue.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#Base.push!-Tuple{PeaceFounder.Model.BallotBox, PeaceFounder.Model.CastRecord}","page":"PeaceFounder.Model","title":"Base.push!","text":"push!(ledger::BallotBox, record::CastRecord)\n\nPush a record to the ledger bypassing integrity checks. Used when loading the ledger from a trusted source such as local disk or an archive with a signed root cheksum.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.leaf-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"HistoryTrees.leaf","text":"leaf(ledger::BallotBox, N::Int)::Digest\n\nReturn a record digest used to form a history tree.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.root-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(ledger::BallotBox[, N::Int])::Digest\n\nCalculate a root for history tree at given index N. If index is not specified returns the current value.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#HistoryTrees.root-Tuple{PeaceFounder.Model.BallotBoxState}","page":"PeaceFounder.Model","title":"HistoryTrees.root","text":"root(state::BallotBoxState)\n\nReturn a history tree root for a current ballotbox ledger state.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_cast-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_cast","text":"ack_cast(ledger::BallotBox, index::Int)::CastAck\n\nCompute an acknowledgment for record inclusion at index.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_cast-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_cast","text":"ack_cast(station::PollingStation, uuid::UUID, N::Int)::CastAck\n\nReturn inclusion proof with receipt and current tree commit for a leaf at index N and ballotbox with uuid. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_leaf-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_leaf","text":"ack_leaf(ledger::BallotBox, index::Int)::AckInclusion\n\nCompute an inclusion proof ::AckInclusion for record element at given index.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_leaf-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_leaf","text":"ack_leaf(station::PollingStation, uuid::UUID, N::Int)::AckInclusion\n\nReturn history tree inclusion proof for a tree leaf at index N in ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_root-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_root","text":"ack_root(ledger::BallotBox, index::Int)::AckConsistency\n\nCompute a history tree consistency proof at index. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ack_root-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ack_root","text":"ack_root(station::PollingStation, uuid::UUID, N::Int)::AckConsistency\n\nReturn history tree consitency proof tree root at index N in ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.add!-Tuple{PeaceFounder.Model.PollingStation, PeaceFounder.Model.Proposal, Set{PeaceFounder.Model.Pseudonym}, PeaceFounder.Model.Pseudonym}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.add!","text":"add!(station::PollingStation, proposal::Proposal, voters::Set{Pseudonym}[, collector::Pseudonym])\n\nCreates a new ballotbox for given proposal with provided member pseudonyms at a relative generator anchored in the proposal.  A collector is optional and provided only when it differs from one specified in the proposal. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ballotbox-Tuple{PeaceFounder.Model.PollingStation, Base.UUID}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ballotbox","text":"ballotbox(station::PollingStation, uuid::UUID)::BallotBox\n\nReturn a ballotbox ledger with a provided UUID. If none is found throws an error.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ballotbox-Tuple{PeaceFounder.Model.PollingStation, PeaceFounder.Model.Digest}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ballotbox","text":"ballotbox(station::PollingStation, proposal::Digest)::BallotBox\n\nReturn a ballotbox which has proposal with provided digest.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit!-Tuple{PeaceFounder.Model.BallotBox, Dates.DateTime, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit!","text":"commit!(ledger::BallotBox[, timestamp::DataTime], signer::Signer; with_tally=nothing)\n\nFlushes ballotbox ledger's queue and creates a commit for a current ballotbox ledger state with provided timestamp and signer. A keyword argument with_tally has three values true|false to include or exclude a tally from a commited state and nothing which uses a previous commit preference.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit!-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit!","text":"commit!(station::PollingStation, uuid::UUID, collector::Signer; with_tally = nothing)\n\nSelect a ballotbox with provided uuid and commit it's state with collector. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(ledger::BallotBox)\n\nReturn a commit for the ballotbox ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit-Tuple{PeaceFounder.Model.CastAck}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(ack::CastAck)\n\nReturn a commit from a CastAck.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit-Tuple{PeaceFounder.Model.PollingStation, Base.UUID}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit","text":"commit(station::PollingStation, uuid::UUID)::Commit\n\nReturn a ballotbox commit.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit_index-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit_index","text":"commit_index(ledger::BallotBox)::Union{Index, Nothing}\n\nIndex at which commit is issued. See also length and index\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.commit_state-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.commit_state","text":"commit_state(ledger::BallotBox)\n\nReturn a committed state for a ballotbox ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(ledger::BallotBox)\n\nReturn a relative generator which members use to sign votes anchored by the proposal.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.generator-Tuple{PeaceFounder.Model.Proposal}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.generator","text":"generator(proposal::Proposal)\n\nA relative generator for at which memebers sign votes for this proposal.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.index-Tuple{PeaceFounder.Model.BallotBoxState}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(state::BallotBoxState)\n\nReturn an index for a current ballotbox ledger state.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.index-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.index","text":"index(ledger::BallotBox)\n\nReturn the current index of the ledger. See also length.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.BraidChain, PeaceFounder.Model.ChainState}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(chain::BraidChain, state::ChainState)::Bool\n\nCheck that chain state is consistent with braidchain ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.CastAck, PeaceFounder.Model.Proposal, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(ack::CastAck, proposal::Proposal, hasher::Hash)::Bool\n\nCheck that acknowledgment is legitimate meaning that it is issued by a collector listed in the proposal.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.CastReceipt, PeaceFounder.Model.AckInclusion, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(receipt::CastReceipt, ack::AckInclusion, hasher::Hash)::Bool\n\nCheck that cast receipt is binding to received inclusion acknowledgment.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.CastReceipt, PeaceFounder.Model.Vote, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(receipt::CastReceipt, vote::Vote, hasher::Hash)::Bool\n\nCheck that the receipt is bidning to a vote. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.Vote, PeaceFounder.Model.CastAck, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(vote::Vote, ack::CastAck, hasher)\n\nCheck whether acknowledgment is bound to the provided vote.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isbinding-Tuple{PeaceFounder.Model.Vote, PeaceFounder.Model.Proposal, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isbinding","text":"isbinding(vote::Vote, proposal::Proposal, crypto::CryptoSpec)\n\nCheck that the vote is bound to a proposal.. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.isconsistent-Tuple{PeaceFounder.Model.Selection, PeaceFounder.Model.Ballot}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.isconsistent","text":"isconsistent(selection::Selection, ballot::Ballot)\n\nVerifies that voter's selection is consistent with ballot form. For instance, whether selection  is withing the range of ballot options.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.issuer-Tuple{PeaceFounder.Model.Proposal}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.issuer","text":"issuer(proposal::Proposal)\n\nIssuer of approval for the proposal.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ledger-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ledger","text":"ledger(ballotbox::BallotBox)::Vector{CastRecord}\n\nReturn all records from a ballotbox ledger.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.ledger-Tuple{PeaceFounder.Model.PollingStation, Base.UUID}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.ledger","text":"ledger(station::PollingStation, uuid::UUID)::Vector{CastRecord}\n\nReturn a vector of records from a ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.members-Tuple{Any}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.members","text":"members(ledger::BallotBox)\n\nReturn a list of member pseudonyms with which members authetificate their votes.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.pseudonym-Tuple{PeaceFounder.Model.Vote}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.pseudonym","text":"pseudonym(vote::Vote)::Union{Pseudonym, Nothing}\n\nReturn a pseudonym with which vote is sealed.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.receipt-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.receipt","text":"receipt(ledger::BallotBox, index::Int)::CastReceipt\n\nReturn a receipt for a ledger element.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.receipt-Tuple{PeaceFounder.Model.CastRecord, PeaceFounder.Model.Hash}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.receipt","text":"receipt(record::CastRecord, hasher::Hash)::CastReceipt\n\nConstruct a CastReceipt from a CastRecord with a provided hasher function.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.receipt-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.receipt","text":"receipt(station::PollingStation, uuid::UUID, N::Int)::CastReceipt\n\nReturn a receipt for a record with index N at ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record!-Tuple{PeaceFounder.Model.BallotBox, PeaceFounder.Model.CastRecord}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record!","text":"record!(ledger::BallotBox, record::CastRecord)\n\nCheck the vote in the record for validity and include that in the ledger directly bypassing queue.  This method is useful for replaying and debugging ballotbox ledger state changes.  See also record!\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record!-Tuple{PeaceFounder.Model.BallotBox, PeaceFounder.Model.Vote}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record!","text":"record!(ledger::BallotBox, vote::Vote)\n\nCheck the vote for validity and pushes it to the queue. Returns an index N at which the vote will be recorded in the ledger. See also push!\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record!-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, PeaceFounder.Model.Vote}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record!","text":"record!(station::PollingStation, uuid::UUID, vote::Vote)::Int\n\nRecords a vote in a ballotbox with provided proposal UUID. Throws an error if a ballotbox can't be found.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record!-Tuple{PeaceFounder.Model.PollingStation, PeaceFounder.Model.Vote}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record!","text":"record!(station::PollingStation, uuid::UUID, vote::Vote)::Int\n\nRecord a vote in a ballotbox found by proposal diggest stored in the vote.  Throws an error if a ballotbox can't be found.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record-Tuple{PeaceFounder.Model.BallotBox, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record","text":"record(ledger::BallotBox, index::Int)::CastRecord\n\nReturn a ledger record at provided index.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.record-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, Int64}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.record","text":"record(station::PollingStation, uuid::UUID, N::Int)::CastRecord\n\nReturn a record with an index N at ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.reset_tree!-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.reset_tree!","text":"reset_tree!(ledger::BallotBox)\n\nRecompute history tree root and cache from the elements in the ledger. This is a useful for loading the ledger all at once.  \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.seed-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.seed","text":"seed(ledger::BallotBox)::Union{Digest, Nothing}\n\nReturn a random selected seed used in the voting.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.set_seed!-Tuple{PeaceFounder.Model.BallotBox, PeaceFounder.Model.Digest}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.set_seed!","text":"set_seed!(ledger::BallotBox, seed::Digest)\n\nSet's a seed of the ballotbox.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.set_seed!-Tuple{PeaceFounder.Model.PollingStation, Base.UUID, PeaceFounder.Model.Digest}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.set_seed!","text":"set_seed!(station::PollingStation, uuid::UUID, seed::Digest)\n\nSets a seed for a ballotbox with provided uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.spine-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.spine","text":"spine(ledger::BallotBox)::Vector{Digest}\n\nReturn a history tree leaf vector.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.spine-Tuple{PeaceFounder.Model.PollingStation, Base.UUID}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.spine","text":"spine(station::PollingStation, uuid::UUID)::Vector{Digest}\n\nReturn a leaf vector for a ballotbox with proposal uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.state-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.state","text":"state(ledger::BallotBox; with_tally::Union{Nothing, Bool} = nothing)::BallotBoxState\n\nReturn a state metadata for ballotbox ledger. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.state-Tuple{PeaceFounder.Model.Proposal}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.state","text":"state(proposal::Proposal)::ChainState\n\nA braidchain ledger state which is used to anchor a relative generator for members.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.tally-Tuple{PeaceFounder.Model.Ballot, AbstractVector{PeaceFounder.Model.Selection}}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.tally","text":"tally(ballot::Ballot, ballots::AbstractVector{Selection})::Tally\n\nCount ballots, check that they are filled consistently and return a final tally.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.tally-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.tally","text":"tally(ledger::BallotBox)\n\nCompute a tally for a ballotbox ledger. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.tally-Tuple{PeaceFounder.Model.PollingStation, Base.UUID}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.tally","text":"tally(station::PollingStation, uuid::UUID)\n\nCompute a tally from ledger records a ballotbox with uuid.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.uuid-Tuple{PeaceFounder.Model.BallotBox}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.uuid","text":"uuid(ledger::BallotBox)\n\nReturn a UUID of the proposal.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.uuid-Tuple{PeaceFounder.Model.Proposal}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.uuid","text":"uuid(proposal::Proposal)::UUID\n\nUUID for a proposal. Issued by proposer and it's purpose is to croslink to an external system durring the proposal dreafting stage.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.validate-Tuple{PeaceFounder.Model.BallotBox, PeaceFounder.Model.Vote}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.validate","text":"validate(ledger::BallotBox, vote::Vote)\n\nCheck that vote can be included in the ballotbox. Is well formed, signed by a member pseudonym and cryptographic signature is valid. Raises error if either of checks fail.\n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.verify-Tuple{PeaceFounder.Model.CastAck, PeaceFounder.Model.CryptoSpec}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.verify","text":"verify(ack::CastAck, crypto::CryptoSpec)::Bool\n\nVerify the cast acknowledgment cryptographic signature. \n\n\n\n\n\n","category":"method"},{"location":"model_api/#PeaceFounder.Model.vote-Tuple{PeaceFounder.Model.Proposal, PeaceFounder.Model.Digest, PeaceFounder.Model.Selection, PeaceFounder.Model.Signer}","page":"PeaceFounder.Model","title":"PeaceFounder.Model.vote","text":"vote(proposal::Proposal, seed::Digest, selection::Selection, member::Signer; seq = 1)\n\nIssue a vote on a proposal and provided collector seed for a member's selection. \n\n\n\n\n\n","category":"method"},{"location":"#PeaceFounder.jl","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"","category":"section"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"(Image: ) (Image: ) With the advancement of technology, remote electronic voting systems are becoming more prevalent in many contexts. Often the e-voting systems are designed as a two-step process where in the first step, voters cast encrypted votes, and, in the second step, the encrypted ballots are shuffled between different independent parties for anonymity and then decrypted. However, in these systems' privacy, transparency, and security remain in tension. Making all evidence public would violate the right of voters to keep their decision to participate secret, whereas including more parties who collectively decrypt the votes to ensure the anonymity of the voters could open adversaries an opportunity to prevent the election result from being decrypted or to assemble the entire decryption key providing means to know how exactly each voter had voted. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"An alternative approach is to anonymise voters instead of votes who cast them with a pseudonym. So far, proposed systems have focused on one-time large-scale elections where the relative generator is predetermined at the registration phase. That reduces complexity for the voter but puts a burden on the election authority to coordinate honest execution of re-encryption shuffle and threshold decryption between all involved parties. Although honesty of execution is guaranteed with zero-knowledge proofs, it does not prevent adversary-sabotaged communication issues. Thus, some baseline of trust is necessary for mixes to guarantee the reliability of the mix phase. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"PeaceFounder system differs from existing solutions by doing public key anonymisation for one mix at a time, after which the relative generator, zero-knowledge shuffle, and decryption proofs are published to the bulletin board. Since there is no coordination between mixes, it makes the protocol more reliable. It is important to note that this also makes the anonymisation easier to understand and more accessible to a broader audience as the mixing procedure is local and can be viewed as a function braid(generator, members) -> (new_generator, new_members) that can be visually represented as a knot-tying together multiple threads.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"The PeaceFounder system demonstrates the feasibility of continuously enrolling new members who are anonymised equally with other members in subsequent mixings. The bulletin board is implemented as a Merkle tree where every new member, braid and proposal are recorded in a ledger, forming a transactional database available to everyone to verify. The clients are thin and use Merkle tree inclusion proofs to assert their membership and to get proof that an election authority provides a given proposal and can be held accountable for its correctness, including the relative generator with which the votes are being cast. To assert the integrity of the bulletin board, the clients would periodically download Merkle consistency proofs from the election authority.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"One of the significant advantages of the PeaceFounder system over existing solutions is that a single person can deploy and maintain this system without compromising privacy, security or transparency. It does not rely on the trust of the honest execution of the ceremony for the setup parameters as it is with some cryptocurrency systems, nor does the need to coordinate correct threshold decryption between multiple parties as needed for a re-encryption-based mixnet voting system. This makes it more accessible to smaller communities which want to offer strong software-independent evidence to everyone and assure the members that their vote is anonymous, guaranteed with multiple braids made in different geographical locations.  ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"In addition to existing e-voting solutions, PeaceFounder is made with integration in mind. It's easy (when that will be documented) to use it in existing community webpages or forums, which have their own ways of selecting and authenticating members. Also, it is easy for the administrator to design procedures in which proposals get accepted for the members to vote and display the progress of the current and past proposals as they are being run. Even more unlimited options to design preferential cardinal or budget-constrained ballots are available while ensuring that election evidence provides software independence for everyone. Meanwhile, the votes are cast within a client GUI application offering security and privacy guarantees for the voters. In summary, if you use an e-voting solution on a website, you will benefit from transparency, security and privacy by using PeaceFounder with little to lose in usability. ","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"PeaceFounder system relies on established ElGamal re-encryption mixnet zero-knowledge proof of shuffle and digital signature algorithm. On top of that, it is assumed that an anonymous communication channel that prevents tracking by IP address is available. Thus a list of assumptions are:","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"DDH hard ensuring computational anonymity;\nInfeasible to do a discrete logarithm;\nAnonymous channel over which to cast a vote;\nWhen evidence of misbehaving election authority is collected/presented, adequate local actions select a new replacement.","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"The PeaceFounder system is implemented in Julia with a client user interface written in QML and is available under Apache 2 license on GitHub. Currently, the system is demonstrated as a technical preview intended to test the usability of a happy path. Nevertheless, digital signatures are implemented in CryptoSignatures.jl complies with FIPS standards and re-encryption proof of shuffle is implemented in ShuffleProofs.jl complies with the Verificatum verifier. A proper specification for proof of correct decryption with a single party and canonicalisation of signed data is missing and will be fixed in the future. ","category":"page"},{"location":"#Demo","page":"PeaceFounder.jl","title":"Demo","text":"","category":"section"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"For a demo, go to PeaceFounderDemo repository. A 10-minute youtube demonstration is available here:","category":"page"},{"location":"","page":"PeaceFounder.jl","title":"PeaceFounder.jl","text":"(Image: IMAGE ALT TEXT HERE)","category":"page"},{"location":"setup/#Setup","page":"Setup","title":"Setup","text":"","category":"section"},{"location":"setup/","page":"Setup","title":"Setup","text":"A setup will be written here. ","category":"page"}]
}
